/* vim: set ts=8 sw=8 : */

#include <cstdlib>
#include <cstdio>
#include <cmath>
#include <iostream>
#include <vector>

#include "opencv2/core/core.hpp"
#include "opencv2/opencv.hpp"

using namespace cv;

const char*       VIDEO_FILE          = "../data/balance.m4v";

const char*       WINDOW_NAME         = "mainwindow";
const int         WINDOW_WIDTH        = 1046;
const int         WINDOW_HEIGHT       = 641;
const int         WINDOW_X_POS        = 0;
const int         WINDOW_Y_POS        = 0;

const Size        SELECT_SIZE         = Size(50, 80);
const unsigned    SELECT_LINE_WIDTH   = 2;
const unsigned    TEXT_LINE_PITCH     = 16;

enum model_state { UNRESOLVED = 0, VALID };

typedef struct {
        model_state state;
        Point pt;
        Rect rect;        

        std::vector<std::vector<Point> > contours;

        double aspect_ratio;
        double contour_area;
} selection_t;

typedef struct {
        model_state state;        
        Point centroid;
        Size size;
} key_zero_t;

typedef struct {
        int canny_threshold;

        selection_t selection;
        key_zero_t key_zero;

        bool scene_cache_valid;
        Mat scene_cache;

        std::vector<std::vector<Point> > match_contours;
} model_t;

static void post_process_roi(const Mat& src, Mat& dst)
{
        static Mat a, b;

        medianBlur(src, a, 3);
        bilateralFilter(a, b, 5, 75, 75);
        cvtColor(b, dst, CV_BGR2GRAY);
}

static void get_selection_contours(model_t& model, Mat& scene)
{
        selection_t& selection = model.selection;
        static Mat roi, canny;

        selection.state = UNRESOLVED;

        post_process_roi(scene(selection.rect), roi);
        Canny(roi, canny, model.canny_threshold, model.canny_threshold * 3, 3);

        static std::vector<Vec4i> hierarchy;

        findContours(canny, selection.contours, hierarchy, CV_RETR_EXTERNAL,
                        CV_CHAIN_APPROX_TC89_L1);

        if (selection.contours.size() != 1)
                return;

        const RotatedRect& bounds = minAreaRect(selection.contours[0]);
        selection.aspect_ratio = bounds.size.height / (double) bounds.size.width;
        selection.contour_area = contourArea(selection.contours[0]);

        selection.state = VALID;
}

static void find_selection(model_t& model, Mat& scene)
{
        if (model.selection.state != VALID)
                return;

        model.match_contours.clear();

        post_process_roi(scene, model.scene_cache);
        model.scene_cache_valid = true;

        static Mat canny;

        Canny(model.scene_cache, canny, model.canny_threshold, model.canny_threshold * 3, 3);

        static std::vector<std::vector<Point> > contours;
        static std::vector<Vec4i> hierarchy;

        findContours(canny, contours, hierarchy, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_TC89_L1);

        unsigned match_shapes = 0;
        unsigned match_survivers = 0;

        for (unsigned i = 0; i < contours.size(); i++) {
                double ratio = matchShapes(model.selection.contours[0], contours[i],
                                CV_CONTOURS_MATCH_I3, 0);

                match_shapes++;

                if (ratio > 0.10) // poor match
                        continue;

                const RotatedRect bounds = minAreaRect(contours[i]);
                double aspect_ratio = bounds.size.height / (double) bounds.size.width; 

                if (std::fabs(aspect_ratio - model.selection.aspect_ratio) > 0.1)
                        continue;

                double contour_area = contourArea(contours[i]);

                if (std::fabs(contour_area - model.selection.contour_area) >
                                model.selection.contour_area * 0.1)
                        continue;

                model.match_contours.push_back(contours[i]);
                match_survivers++;
        }

        std::cout << "match_shapes=" << match_shapes <<
                " match_survivers=" << match_survivers << std::endl;
}

static void handle_mouse_event(int e, int x, int y, int flags, void* param)
{
        selection_t& selection = ((model_t*) param)->selection;

        selection.pt.x = x;
        selection.pt.y = y;

        selection.rect.x = selection.pt.x - SELECT_SIZE.width / 2;
        selection.rect.x = selection.pt.y - SELECT_SIZE.height / 2;
        selection.rect.width = SELECT_SIZE.width;
        selection.rect.height = SELECT_SIZE.height;

        std::cout << selection.rect << std::endl;
        selection.state = UNRESOLVED;
}

static void paint_picture_in_picture(model_t& model, Mat& scene)
{
        Rect pip_rect(Point(), SELECT_SIZE);
        scene(model.selection.rect).copyTo(scene(pip_rect));
}

int main(int argc, const char** argv)
{

        VideoCapture vc;
//        std::vector<char> s(4096);


        int key = 0;
        bool pause = false;

        namedWindow(WINDOW_NAME, CV_WINDOW_NORMAL);
        moveWindow(WINDOW_NAME, WINDOW_X_POS, WINDOW_Y_POS);
        resizeWindow(WINDOW_NAME, WINDOW_WIDTH, WINDOW_HEIGHT);

        model_t model = {};

        handle_mouse_event(0, 200, 200, 0, (void*) &model);
        setMouseCallback(WINDOW_NAME, handle_mouse_event, (void*) &model); 

        model.canny_threshold = 35;
        createTrackbar("thresh", WINDOW_NAME, &model.canny_threshold, 100);

        Mat scene;

        while (true)
        {
                if ((unsigned long) cvGetWindowHandle(WINDOW_NAME) == 0UL) // window closed
                        break;

                if (!pause) {
                        if (! vc.isOpened()) {
                                if (! vc.open(VIDEO_FILE)) {
                                        CV_Error_(-1, ("failed to open video: \"%s\"", VIDEO_FILE));
                                        std::exit(1);
                                }
                        }
                        if (! vc.read(scene)) {
                                vc.release();
                                continue;
                        }
                }

                paint_picture_in_picture(model, scene);
                imshow(WINDOW_NAME, scene);

//                medianBlur(pristine, a, 3);
//                bilateralFilter(a, b, 5, 75, 75);
//                cvtColor(b, a, CV_BGR2GRAY);
//
//                Mat& post = a;
//
//
//                Mat canny;
//
//                double s_aspect_ratio;
//                double s_area;
//
//                if (selection.newSelection) {
//                        selection.newSelection = false;
//
//                        Canny(post(selectedRect), canny, thresh, thresh * 3, 3);
//                        findContours(canny,
//                                        contourSelection,
//                                        hierarchySelection,
//                                        CV_RETR_EXTERNAL,
//                                        CV_CHAIN_APPROX_TC89_L1);
//
//                        std::cout << "--" << std::endl
//                                << "contourSelection.size()=" << contourSelection.size() << std::endl;
//
//                        for (i = 0; i < 1; i++) {
//                                //std::cout << contourSelection[i] << std::endl;
//                                const RotatedRect& s_bounds = minAreaRect(contourSelection[i]);
//                                s_aspect_ratio =  s_bounds.size.height / (double)s_bounds.size.width;
//                                s_area = contourArea(contourSelection[i]);
//                                std::cout << i << ":"
//                                        << " bounds=" << s_bounds.size
//                                        << " aspect ratio=" << s_aspect_ratio
//                                        << " area=" << s_area << std::endl;
//                        }
//                }
//
//                Canny(post, canny, thresh, thresh * 3, 3);
//                findContours(canny,
//                                contourScene,
//                                hierarchyScene,
//                                CV_RETR_EXTERNAL,
//                                CV_CHAIN_APPROX_TC89_L1);
//
//                for (i = 0; i < 1; i++) {
//                        unsigned match_shapes = 0;
//                        unsigned match_survivers = 0;
//
//                        for (j = 0; j < contourScene.size(); j++) {
//
//                                match = matchShapes(contourSelection[i],
//                                                contourScene[j],
//                                                CV_CONTOURS_MATCH_I3,
//                                                0);
//
//                                match_shapes++;
//
//                                if (match >= 0.10)
//                                        continue;
//
//                                const RotatedRect m_bounds = minAreaRect(contourScene[j]);
//                                double m_aspect_ratio = m_bounds.size.height / (double)m_bounds.size.width; 
//
//                                if (std::fabs(s_aspect_ratio - m_aspect_ratio) > 0.1)
//                                        continue;
//
//                                double m_area = contourArea(contourScene[j]);
//
//                                if (std::fabs(s_area - m_area) > s_area * 0.1)
//                                        continue;
//
//                                drawContours(post,
//                                                contourScene,
//                                                j,
//                                                Scalar(255,255,255),
//                                                1,
//                                                8,
//                                                hierarchyScene,
//                                                2);
//
//                                match_survivers++;
//                        }
//
//                        std::cout << "match_shapes=" << match_shapes
//                                << " match_survivers=" << match_survivers << std::endl;
//                }
//
//                cvtColor(post, color, CV_GRAY2BGR);
//                color(selectedRect).copyTo(color(pipRect));
//
//                rectangle(color, selectedRect, Scalar(0,255,0), SELECT_LINE_WIDTH);
//
//                std::sprintf(&s[0], "CNT: %5u", (unsigned) vc.get(CV_CAP_PROP_FRAME_COUNT));
//                putText(color,
//                                &s[0],
//                                Point(vc.get(CV_CAP_PROP_FRAME_WIDTH)-200,TEXT_LINE_PITCH * 1),
//                                FONT_HERSHEY_PLAIN,
//                                1,
//                                Scalar(255,255,255));
//
//                std::sprintf(&s[0], "F#:  %5u", (unsigned) vc.get(CV_CAP_PROP_POS_FRAMES));
//                putText(color,
//                                &s[0],
//                                Point(vc.get(CV_CAP_PROP_FRAME_WIDTH)-200,TEXT_LINE_PITCH * 2),
//                                FONT_HERSHEY_PLAIN,
//                                1,
//                                Scalar(255,255,255));
//
//                imshow(WINDOW_NAME, color);

                key = waitKey(1);

                if (key == 27) {
                        break;
                }
                else if (key == 32) {
                        pause = !pause;
                }
        }

        vc.release();

        return 0;
}

